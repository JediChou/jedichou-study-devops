#####################################################################
# File name: tc_Array.rb
# Create date: 2013-8-31 14:11 PM
# Update date: 2013-9-23 11:24 PM
# Description: Cross write unit test to study build-in classes
#####################################################################
# Author  : Jedi Chou
# From    : Programming Ruby 1.9 & 2.0
#           The Pragmatic Programmers' Guide
# ISBN-13 : 978-1-93778-549-9
#####################################################################

require "test/unit"

class TC_Array < Test::Unit::TestCase

	# << From page 421 >>
	# ---------------------------------------------------------------
	# Returns a new array populated with the given object. Equivalent
	# to the operator from Array.[...].
	def test_Array_ClassMethods_UseBracketsToCreateArray
		assert [1, "a", /^A/], Array.[]( 1, "a", /^A/ )
		assert [1, "a", /^A/], Array[1, "a", /^A/]
		assert [1, "a", /^A/], [1, "a", /^A/]
	end

	# << From page 421 - 422 >>
	# ---------------------------------------------------------------
	# Returns a new array. In the first form, the new array is empty.
	# In the second, it is created with size copies of obj (that is,
	# size references to the same obj). The third form creates a copy
	# of the array passed as a parameter (the array is generated by
	# calling to_array on the parameter). In the last form, an array
	# of the given size is created. Each element in this array is
	# calculated by passing the element's index to the given block
	# and storing the return value.
	def test_Array_ClassMethods_UseNewToCreatArray
		assert [], Array.new
		assert [nil, nil], Array.new(2)
		assert ["A", "A", "A", "A", "A"], Array.new(5, "A")

		a = Array.new(2, Hash.new)
		a[0]['cat'] = 'feline'
		assert [{"cat"=>"feline"}, {"cat"=>"feline"}], a
		a[1]['cat'] = 'Felix'
		assert [{"cat"=>"Felix"}, {"cat"=>"Felix"}], a

		a = Array.new(2) { Hash.new }
		a[0]['cat'] = 'feline'
		assert [{"cat"=>"feline"}, {}], a

		squares = Array.new(5) {|i| i*i}
		assert [0,1,4,9,16], squares

		copy = Array.new(squares)
		squares[5] = 25
		assert 25, squares[5]
		assert [0,1,4,9,16, 25], squares
		assert [0,1,4,9,16], copy
	end

	# << From page 422 >>
	# ---------------------------------------------------------------
	# If obj is not already an array, attempts to convert it to one 
	# by calling its to_ary method. Returns nil if no conversion could
	# be made.
	def test_Array_ClassMethods_UseTryConvert
		assert ["Larry","Curly","Moe"], Array.try_convert(Stooges.new)
		assert Array.try_convert("Shemp") == nil
	end

	# << From page 422 >>
	# ---------------------------------------------------------------
	# Set Intersection -- Returns a new array containing elements
	# common to the two arrays, with no duplicates. The rules for
	# comparing elements are the same as for hask keys. If you need
	# setlike behavior, see the library class. << set on page 804.>>
	def test_Array_InstanceMethod_SetIntersection
		assert [1,3], [1,1,3,5] & [1,2,3]
	end

	# << From page 422 >>
	# ---------------------------------------------------------------
	# Repetition - With an argument that responds to to_str, equival-
	# ent to arr.join(str). Otherwise, returns a new array built by
	# concatenating int copies to arr.
	def test_Array_InstanceMethod_Repetition
		assert [1,2,1,2], [1,2] * 2
		assert [1--2--3], [1,2,3] * "--"
	end

	# << From page 422 >>
	# ---------------------------------------------------------------
	# Concatenation -- Returns a new array built by concatenating the
	# two arrays together to produce a third array.
	def test_Array_InstanceMethod_Concatenation
		assert [3,3,5], [1,1,2,2,3,3,4,4,5] - [1,2,4]
	end

	# << From page 423 >>
	# ---------------------------------------------------------------
	# Append -- Pushes the given object on to the end of this array.
	# This expression returns the array itself, so several appends 
	# may be chained together. See also Array#push.
	def test_Array_InstanceMethod_Append
		assert [1,"b"], [1] << "b"
		assert [1, [3,4]], [1] << [3,4]
		assert [1, "b", [3,4] ], [1] << "b" << [3,4]
	end

	# << From page 423 >>
	# ---------------------------------------------------------------
	# Comparison -- Returns an integer - 1, 0, or +1 if this array is
	# less than, equal to, or greater than other_array. Successive
	# object in each array are compared using <=>. If any pair are not
	# equal, the that inequality is the return value. If all pair are
	# equal, then the longer array is considered greater. Thus, two
	# arrays are "equal" according to Array#<=> if and only if they
	# have the same length and the values of each corresponding element
	# are equal. nil is return if the argument is not comparable to arr.
	def test_Array_InstanceMethod_Comparision
		assert(-1, ["a","a","c"] <=> ["a","b","c"])
		assert(1, [1,2,3,4,5,6,7] <=> [1,2])
		assert(true, [1,2,3,4,5,6,7] <=> [1,2])
		assert_raises(TypeError) {[1,2,3] <=> "wombat"}
	end

	# << From page 423 >>
	# ---------------------------------------------------------------
	# arr == obj -> true or false
	# ---------------------------------------------------------------
	# Equality -- Two arrays are equal if they contain the same number
	# of elements and if each element is equal to (acorrding to Object
	# #==) the corresponding element in the other array. If obj is not
	# an array, attempt to convert it using to_ary and renturn 
	# obj==arr.
	def test_Array_InstanceMethod_Equality
		assert (["a","c"] == ["a","c",7]) == false
		assert ["a","c",7] == ["a","c",7]
		assert (["a","c",7] == ["a","c","f"]) == false
	end

	# << From page 423 >>
	# ---------------------------------------------------------------
	#           arr[int] -> obj or nil
	# arr[start, length] -> an_array or nil
	#         arr[range] -> an_arry or nil
	# ---------------------------------------------------------------
	# Element Reference -- Returns the element at index int; returns
	# a length element subarray starting at index start; or returns a
	# subarray specified by range. Negative indices count backward
	# from the end of the array (-1 is the last element). Returns nil
	# if the index of the first selected is greater than the array
	# size. If the start index equals the array size and a length or
	# range parameter is given, an empty array is returned. Equivalent
	# to Array#slice.
	def test_Array_InstanceMethod_ElementReference
		a = ["a", "b", "c", "d", "e"]
		assert "cab", a[2]+a[0]+a[1]
		assert a[6] == nil
		assert ["b","c"], a[1,2]
		assert ["b","c","d"], a[1,3]
		assert ["e"], a[4,7]
		assert a[6,10] == nil
		assert ["c", "d"], a[-3,3]

		# special case
		assert a[5] == nil
		assert [], a[5, 1]
		assert [], a[5..10]
	end

	# << From page 424 >>
	# ---------------------------------------------------------------
	#           arr[int] = obj -> obj
	# arr[start, length] = obj -> obj
	#         arr[range] = obj -> obj
	# ---------------------------------------------------------------
	# Element Assignment - Sets the element at index int, replaces a
	# subarray starting at index start and continuing for length el-
	# ements, or replaces a subarray specified by range. If int is
	# greater than the size of the array, the array grows automatically.
	# a negative int counts backward from the end of the array. Insert
	# elements if length is zero. If obj is an array, the from with
	# the single index inserts that array into arr, and the forms with
	# a length or with a range replace the given elements in arr with
	# the array contents. An IndexError is raised if a negative index
	# points past the beginning of the array. (Prior to Ruby 1.9,
	# assigning nil with the second and third forms of elements 
	# assignment deleted the corresponding array elements; it now assigns
	# nil to them.) See also Array#push and Array#unshift.
	def test_Array_InstanceMethod_ElementAssignment
		a = Array.new; assert [], a
		a[4] = "4"; assert [nil,nil,nil,nil,"4"], a
		a[0] = [1,2,3]; assert [[1,2,3],nil,nil,nil,"4"], a
		a[0,3] = ['a','b','c']; assert ['a','b','c',nil,'4'], a
		a[1..2] = [1,2]; assert ['a',1,2,nil,'4'], a
		a[0,2] = '?'; assert ['?',2,nil,'4']
		a[0..2]='A','B','C'; assert ['A','B','C','4'], a
		a[-1] = 'Z'; assert ['A','B','C','Z'], a
		a[1..-1] = nil;	assert ['A',nil], a
	end

	# << From page 424 >>
	# ---------------------------------------------------------------
	# arr | other_array -> an_array
	# ---------------------------------------------------------------
	# Set Union -- Returns a new array by joining this array with
	# other_array, removing duplicates. The rules for comparing ele-
	# ments are the same as for hash keys. If you need setlike behav-
	# ior, see the library class <Set on page 804>.
	def test_Array_InstanceMethod_SetUnion
		assert ['a','b','c','d'], ['a','b','c'] | ['c','d','a']
	end

	# << From page 424 >>
	# ---------------------------------------------------------------
	# arr.assoc(obj) -> an_array or nil
	# ---------------------------------------------------------------
	# Searches through an array whose elements are also arrays compa-
	# ring obj with the first element of each contained array using
	# obj ==. Returns the first contained array that matches (that is,
	# the first associated array) or nil if no match is found. See
	# also Array#rassoc.
	def test_Array_InstanceMethod_Assoc
		# TODO, Jedi don't understand
		s1 = ["colors","red","blue","green"]
		s2 = ["letters","a","b","c"]
		s3 = "foo"
		a = [s1, s2, s3]
		assert ["letters","a","b","c"], a.assoc("letters")
		assert a.assoc("foo") == nil
	end

	# << From page 424 >>
	# ---------------------------------------------------------------
	# arr.at(int) -> obj or nil
	# ---------------------------------------------------------------
	# Returns the element at index int. A negative index counts from
	# the end of arr. Returns nil if the index is out of range. See
	# also Array#[]
	def test_Array_InstanceMethod_At
		a = ["a", "b", "c", "d", "e"]
		assert "a", a.at(0)
		assert "e", a.at(-1)
	end

	# << From page 425 >>
	# ---------------------------------------------------------------
	# arr.bsearch { |val| ... } -> obj or nil
	# ---------------------------------------------------------------
	# A ssuming arr is sorted in ascending order, performs a binary
	# search in O(log n) time. The method operates in two modes
	# depending on the values returned by the block:
	# To find the minimum value in arr greater than or equal to the 
	# required value, have the block return false if its argument is
	# less than that value, true otherwise.
	def test_Array_InstanceMethod_bsearch
		arr = %w{ ant bee cat dog elk fox gnu }
		# TODO, assert "cat", arr.bsearch { |val| val >= "c" }
	end

	# << From the page 425 >>
	# ---------------------------------------------------------------
	#                 arr.combination(size) -> enumerator
	# arr.combination(size) { |array| ... } -> arr
	# ---------------------------------------------------------------
	# Constructs all combinations of the elements of arr of length
	# size. If called with a block, passes each combination to that
	# block; otherwise, returns an enumerator object. An empty result
	# is generated if no combinations of the given length exist. See
	# also Array#permutation .
	def test_Array_InstanceMethod_combination
		a = ["a", "b", "c"]
		assert [["a"], ["b"], ["c"]], a.combination(1).to_a
		assert [["a","b"], ["a","c"], ["b","c"]], a.combination(2).to_a
		assert [["a", "b", "c"]], a.combination(3).to_a
		assert [], a.combination(4).to_a
	end

	# << From the page 425 >>
	# ---------------------------------------------------------------
	# arr.collect! { |obj| ... } -> arr
	# ---------------------------------------------------------------
	# Invokes block once for each element of arr, replacing the element
	# with the value returned by block. See also Enumerable#collect .
	def test_Array_InstanceMethod_collect
		a = [ "a", "b", "c", "d" ]
		a.collect! { |x| x+"!" }
		assert ["a!","b!","c!","d!"], a
	end

	# << From the page 426 >>
	# ---------------------------------------------------------------
	# arr.compact -> an_array
	# ---------------------------------------------------------------
	# Returns a copy of arr with all nil elements removed .
	def test_Array_InstanceMethod_compact
		assert ["a","b","c"], ["a",nil,"b",nil,"c",nil].compact
	end

	# << From the page 426 >>
	# ---------------------------------------------------------------
	# arr.compact! -> arr or nil
	# ---------------------------------------------------------------
	# Removes nil elements from arr. Returns nil if no changes were
	# made .
	def test_Array_InstanceMethod_compact!
		assert ["a","b","c"], ["a",nil,"b",nil,"c"].compact
		assert_equal(nil, ["a","b","c"].compact!)
	end

	# << From the page 426 >>
	# ---------------------------------------------------------------
	# arr.concat(other_array) -> arr
	# ---------------------------------------------------------------
	# Appends the elements in other_array to arr .
	def test_Array_InstanceMethod_concat
		assert ["a","b","c","d"], ["a","b"].concat(["c","d"])
	end

	# << From the page 426 >>
	# ---------------------------------------------------------------
	#          arr.count(obj) -> int
	# arr.count { |obj| ... } -> int
	# ---------------------------------------------------------------
	# Returns the count of objects in arr that equal obj or for which
	# the block returns a true value. Shadows the corresponding method
	# in Enumerable .
	def test_Array_InstanceMethod_count
		assert 1, [1,2,3,4].count(3)
		assert 2, [1,2,3,4].count { |x| x>2 }
	end

	# << From the page 426 >>
	# ---------------------------------------------------------------
	#        arr.cycle { |obj| ... } -> nil or enumerator
	# arr.cycle(times) { |obj| ... } -> nil or enumerator
	# ---------------------------------------------------------------
	# Returns nil if arr has no elements; otherwise, passes the elements,
	# once at a time to the block. When it reaches the end, it repeats.
	# The number of times it repeats is set by the parameter. If the
	# parameter is missing, cycles forever. Returns an Enumerator
	# object if no block is given .
	def test_Array_InstanceMethod_cycle
		assert [1,2,3,1,2,3], [1,2,3].cycle(2).to_a
	end

	# << From the page 427 >>
	# ---------------------------------------------------------------
	#         arr.delete(obj) -> obj or nil
	# arr.delete(obj) { ... } -> obj or nil
	# ---------------------------------------------------------------
	# Deletes items from arr equal to obj. If the item is not found,
	# returns nil. If the optional code block is given, returns the
	# result of block if the item is not found .
	def test_Array_InstanceMethod_delete
		a = ["a", "b", "b", "b", "c"]
		assert "b", a.delete("b")
		assert ["a", "c"], a
		assert_equal(nil, a.delete("z"))
		assert_equal("Not found", a.delete("z") {"Not found"})
	end

	# << From the page 427 >>
	# ---------------------------------------------------------------
	#         arr.delete(obj) -> obj or nil
	# arr.delete(obj) { ... } -> obj or nil
	# ---------------------------------------------------------------
	# Deletes items from arr that are equal to obj. If the item is not
	# found, returns nil. If the optional code block is given, returns
	# of block if the item is not found .
	def test_Array_InstanceMethod_delete_at
		a = %w( ant bat cat dog )
		assert_equal("cat", a.delete_at(2))
		assert_equal(["ant","bat","dog"], a)
		assert_equal(nil, a.delete_at(99))
	end

	# << From the page 427 >>
	# ---------------------------------------------------------------
	# arr.delete_if { |item| ... } -> arr
	# ---------------------------------------------------------------
	# Deletes every element of arr for which block evaluates to true .
	def test_Array_InstanceMethod_delete_if
		a = ["a", "b", "c"]
		assert_equal(["a"], a.delete_if { |x| x>="b"})
	end

	# << From the page 427 >>
	# ---------------------------------------------------------------
	# arr.each { |item| ... } -> arr
	# ---------------------------------------------------------------
	# Calls block once for each element in arr, passing that element
	# as a parameter .
	def test_Array_InstanceMethod_each
		a = ["a","b","c"]
		t_str = ""
		a.each { |x| t_str+x }
		
		assert "abc", t_str
	end

	# << From the page 427 >>
	# ---------------------------------------------------------------
	# arr.each_index { |index| ... } -> arr
	# ---------------------------------------------------------------
	# Same as Array#each but passes the index of the element instead
	# of the element itself .
	def test_Array_InstanceMethod_each_index
		a = ["a", "b", "c"]
		b = []
		a.each_index { |x| b.push(x) }
		assert [0,1,2], b
	end

	# << From the page 428 >>
	# ---------------------------------------------------------------
	# arr.empty? -> true of false
	# ---------------------------------------------------------------
	# Returns true if arr array contains no elements .
	def test_Array_InstanceMethod_empty?
		assert_equal(true, [].empty?)
		assert_equal(false, [1,2,3].empty?)
	end

	# << From the page 428 >>
	# ---------------------------------------------------------------
	# arr.eql?(other) -> true or false
	# ---------------------------------------------------------------
	# Returns true if arr and other are the same object or if other is
	# an object of class Array with the same length content as arr.
	# Elements in the arrays are compared using Object#eql?. See also
	# Array#<=> .
	def test_Arary_InstanceMethod_eql?
		assert_equal(true , ["a","b","c"].eql?(["a","b","c"]))
		assert_equal(false, ["a","b","c"].eql?(["a","b"]))
		assert_equal(false, ["a","b","c"].eql?(["b","c","d"]))
	end

	# << From the page 428 >>
	# ---------------------------------------------------------------
	#             arr.fetch(index) -> obj
	#    arr.fetch(index, default) -> obj
	# arr.fetch(index) { |i| ... } -> obj
	# ---------------------------------------------------------------
	# Tries to return element at position index. If the index lies
	# outside the array, the first form throws an IndexError exception,
	# the second form returns default, and the third form resturns the
	# value of invoking the block, passing in the index. Negative
	# values of index count from the end of the array.
	def test_Array_InstanceMethod_fetch
		a = [11,22,33,44]
		assert 22, a.fetch(1)
		assert 44, a.fetch(-1)
		assert 44, a.fetch(-1, 'cat')
		assert 'cat', a.fetch(4, 'cat')
		assert 16, a.fetch(4) {|i| i*i}
	end

	# << From the page 428 >>
	# ---------------------------------------------------------------
	#                        arr.fill(obj) -> arr
	#        arr.fill(obj, star<, length>) -> arr
	#                 arr.fill(obj, range) -> arr
	#                 arr.fill { |i| ... } -> arr
	# arr.fill(star<, length>) { |i| ... } -> arr
	#          arr.fill(range) { |i| ... } -> arr
	# ---------------------------------------------------------------
	# The first three forms set the selected elements of arr ( which
	# may be the entire array) to obj. A start of nil is equivalent
	# to zero. A length of nil is equivalent to arr.length. The last
	# three forms fill the array with the value of the block. The
	# block is passed the absolute index of each element to be filled
	def test_Array_InstanceMethod_fill
		a = ["a", "b", "c", "d"]
		assert ["x","x","x","x"], a.fill("x")
		assert ["x","x","z","z"], a.fill("z",2,2)
		assert ["y","y","z","z"], a.fill("y",0..1)
		assert [0,1,4,9], a.fill {|i| i*i}
		assert [0,101,102,103], a.fill(-3) {|i| i+100}
	end

	# << From the page 429 >>
	# ---------------------------------------------------------------
	#           arr.find_index(obj) -> int or nil
	# arr.find_index { |item| ... } -> int or nil
	#                arr.find_index -> enumerator
	# ---------------------------------------------------------------
	# Returns the index of the first object in arr that is == to obj
	# or for which the block returns a true value. Returns nil if no
	# match is found. See also Enumerable#select and Array#rindex.
	def test_Array_InstanceMethod_find_index
		a = ["a", "b", "c", "d"]
		assert_equal(1, a.find_index("b"))
		assert_equal(nil, a.find_index("z"))
		assert_equal(1, a.find_index { |x| x>"a" })
	end

	# << From the page 429 >>
	# ---------------------------------------------------------------
	# arr.flatten(level=-1) -> an_array
	# ---------------------------------------------------------------
	# Returns a new array that is a flattening of this array (recursively).
	# That is, for every element that is an array, extracts its elements
	# into the new array. The level parameter controls how deeply the
	# flattening occurs. If less than zero, all subarrays are expended.
	# If zero, no flattening takes place. If greater than zero, only
	# that depth of subarray is expanded.
	def test_Array_InstanceMethod_flatten
		s = [1,2,3]
		t = [4,5,6,[7,8]]
		a = [s,t,9,10]
		assert_equal([[1,2,3], [4,5,6,[7,8]], 9, 10], a.flatten(0))
		assert_equal([1,2,3,4,5,6,7,8,9,10], a.flatten())
		assert_equal([1,2,3,4,5,6,[7,8],9,10], a.flatten(1))
		assert_equal([1,2,3,4,5,6,7,8,9,10], a.flatten(2))
	end

	# << From the page 429 >>
	# ---------------------------------------------------------------
	# arr.flatten!(level=-1) -> arr or nil
	# ---------------------------------------------------------------
	# Same as Array#flatten but modifies the receiver in place. Returns
	# nil if no modifications were made (i.e., arr contains no subarrays).
	def test_Array_InstanceMethod_flatten!
		a = [1, 2, [3, [4, 5] ] ]
		assert_equal([1,2,3,4,5], a.flatten!)
		assert_equal(nil, a.flatten!)
		assert_equal([1,2,3,4,5], a)
	end

	# << From the page 429 >>
	# ---------------------------------------------------------------
	# arr.frozen? -> true or false
	# ---------------------------------------------------------------
	# Returns true if arr is frozen or if it is in the middle of
	# being sorted.
	def test_Array_InstanceMethod_frozen?
		assert_equal(false, [].frozen?)
		assert_equal(false, [1].frozen?)
		assert_equal(false, [1,2].frozen?)

		a = [1,2]; a.freeze
		b = "abc"; b.freeze
		assert_equal(true, a.frozen?)
		assert_equal(true, b.frozen?)
	end

	# << From the page 429 >>
	# ---------------------------------------------------------------
	#           arr.index(obj) -> int or nil
	# arr.index { |item| ... } -> int or nil
	# ---------------------------------------------------------------
	# Synonym for Array#find_index .
	def test_Array_InstanceMethod_index
		# @, Move to absolute position
		# A, Sequence of bytes (space padded, count is width)
		# a, Sequence of bytes (null padded, count is width)
		# B, Bit string (most significant first)
		# b, Bit string (least significant first)
		# C, Unsigned byte
		# c, Byte
		# D,d, Double-precision float, native format
		# E, Double-precision float, little-endian byte order
		# e, Single-precision float, little-endian byte order
		# F, f, Single-precision float, native format
		# G, Double-precision float, network (big-endian) byte order
		# g, Single-precision float, network (big-endian) byte order
		# H, Hex string (high nibble first)
		# h, Hex string (low nibble first)
		# I, Unsigned integer
		# i, Integer
		# L, Unsigned long
		# l, Long
		# M, Quoted printable, MIME encoding (see RFC2045)
		# m, Base64-encoded string; by default adds linefeeds every 60
		#    characters; "m0" suppresses linefeeds
		# N, Long, network (big-endian) byte order
		# n, Short, network (big-endian) byte order
		# P, Pointer to a structure (fixed-length string)
		# p, Pointer to a null-terminated string
		# Q, q, 64-bit number
		# S, Unsigned short
		# s, short
		# U, UTF-8
		# u, UU-encoded string
		# V, Long, little-endian byte order
		# v, Short, little-endian byte order
		# w, BER-compressed integer
		# X, Back up a byte
		# x, Null byte
		# Z, same as "a", except a null byte is appended if * modifier
		#    is given
	end

	# << From the page 431 >>
	# ---------------------------------------------------------------
	# arr.insert(index, <obj>+}) -> arr
	# ---------------------------------------------------------------
	# If index is not negative, inserts the given values before the
	# element with the given index. If index is negative, adds the
	# values after the element with the given index (counting from the
	# end) .
	def test_Array_InstanceMethod_insert
		a = %w{ a b c d }
		assert_equal( ['a','b',99,'c','d'], a.insert(2, 99) )
		assert_equal( ['a','b',99,'c',1,2,3,'d'], a.insert(-2, 1,2,3) )
		assert_equal( ['a','b',99,'c',1,2,3,'d','e'], a.insert(-1, 'e') )
	end

	# << From the page 431 >>
	# ---------------------------------------------------------------
	# arr.join(separator=$,) -> str
	# ---------------------------------------------------------------
	# Returns a string created by converting each element of the array
	# to a string and concatenating them, separated each by separator.
	def test_Array_InstanceMethod_join
		a = ['a','b','c']
		assert 'abc', a.join
		assert 'a-b-c', a.join('-')
	end

	# << From the page 431 >>
	# ---------------------------------------------------------------
	# arr.keep_if { |obj| ... } -> array or enumerator
	# ---------------------------------------------------------------
	# Modifies arr by removing all elements which block is false (see
	# also Enumerable#select and Array.select!). Returns an Enumerator
	# object if no block is given.
	def test_Array_InstanceMethod_keep_if
		a = [1,2,3,4,5,6,7,8,9]
		# TODO, 
		# assert_equal([1,2,3,4,5], a.keep_if {|x| x<6} )
	end

	# << From the page 431 >>
	# ---------------------------------------------------------------
	#        arr.last -> obj or nil
	# arr.last(count) -> an_array
	# ---------------------------------------------------------------
	# Returns the last element, or last count elements, of arr. If the
	# array is empty, the first form returns nil, and the second returns
	# an empty array. (first is defined by Enumerable.)
	def test_Array_InstanceMethod_last
		a = [ "w", "x", "y", "z" ]
		assert 'z', a.last
	end

	# << From the page 431 >>
	# ---------------------------------------------------------------
	# arr.length -> int
	# ---------------------------------------------------------------
	# Returns the number of elements in arr.
	def test_Array_InstanceMethod_length
		assert 5, [1, nil, 1, nil, 2]
	end

	# << From the page 431 >>
	# ---------------------------------------------------------------
	# arr.map! { |obj| ... } -> arr
	# ---------------------------------------------------------------
	# Synonym for Array#collect!.
	def test_Array_InstanceMethod_map!
		a = [ "a", "b", "c", "d" ]
		a.map! { |x| x+"!" }
		assert ["a!","b!","c!","d!"], a
	end

	# << From the page 432 >>
	# ---------------------------------------------------------------
	# arr.pack(template) -> binary_string
	# ---------------------------------------------------------------
	# Packs the contents of arr into a binary sequence according to
	# the directives in template (see Table 14, Template characters
	# for Array.pack, on page 430). Directives A, a, and Z may be
	# followed by a count, which gives the width of the resulting field.
	# The remaining directives also many take a count, indicating the
	# number of array elements to convert. If the count is an asterisk
	# (*), all remaining array elements wil be converted. The directives
	# s S i || L may be followed by an underscore (_) or bang (!) to
	# use the underlying platform's native size for the specified type;
	# otherwise, they use a platform-independent size. The directives
	# s S i || L q Q may be followed by a less than sign to signify
	# little endian or greater than sign for big endian. Spaces are
	# ignored in the template string. Comments starting with # to the
	# next newline or end of string are also ignored. See also 
	# String#upack on page 690.
	def test_Array_InstanceMethod_pack
		a = ['a','b','c']
		n = [65, 66, 67]
		assert 'a  b  c  ', a.pack('A3A3A3')
		assert 'a\0\0b\0\0c\0\0', a.pack('a3a3a3')
		assert 'ABC', n.pack('ccc')
	end

	# << From the page 432 >>
	# ---------------------------------------------------------------
	#                 arr.permutation(size=arr.size) -> enumerator
	# arr.permutation(size=arr.size) { |array| ... } -> arr}
	# ---------------------------------------------------------------
	# Constructs all permutations of the elements of arr of length
	# size. If called with a block, passes each permutation to that
	# block; otherwise, returns an enumerator object. An empty result
	# is generated if no permutations of the given length exist.
	# See also Array#combination.
	def test_Array_InstanceMethod_permutation
		# reference (http://apidock.com/ruby/Array/permutation)
		a = [1, 2, 3]
		assert [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]], a.permutation.to_a
		assert [[1],[2],[3]], a.permutation(1).to_a
		assert [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], a.permutation(2).to_a
		assert [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]], a.permutation(3).to_a
		assert [[]], a.permutation(0).to_a
		assert [], a.permutation(4).to_a
	end

	# << From the page 432 >>
	# ---------------------------------------------------------------
	# arr.pop(<n>*) -> obj or nil
	# ---------------------------------------------------------------
	# Removes the last element (or the last n elements) from arr.
	# Returns whatever is removed or nil if the array is empty.
	def test_Array_InstanceMethod_pop
		a = %w{ f r a b j o u s }
		assert 's', a.pop
		assert ['f','r','a','b','j','o','u'], a
		assert ['j','o','u'], a.pop(3)
		assert ['f','r','a','b'], a
	end

	# << From the page 433 >>
	# ---------------------------------------------------------------
	#                      arr.product(<array>*) -> result_array
	# arr.product(<array>*) < {|combination ...} -> arr
	# ---------------------------------------------------------------
	# Generates all combinations of selecting an element each from
	# arr and from any arrays passed as arguments. The number of 
	# elements in the result is the product of the lengths of arr
	# and the length of the arguments (so if any of these arrays is
	# empty array). Each element in the result is an array containing
	# n+1 elements, where n is the number of arguments. If a block is
	# present, it will be passed each combination, and arr will be
	# returned.
	def test_Array_InstanceMethod_product
		# reference (http://apidock.com/ruby/v1_9_3_392/Array/product)
		result1 = [1,2,3].product([4,5])
		result2 = [1,2].product([1,2])
		result3 = [1,2].product([3,4],[5,6])
		result4 = [1,2].product()
		result5 = [1,2].product([])
		assert [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]], result1
		assert [[1,1],[1,2],[2,1],[2,2]], result2
		assert [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]] , result3
		assert [[1],[2]], result4
		assert [], result5

		# it's mean 3x2x3 = 18
		result6 = ['a','b','c'].product([1,2], ['d','c','f'])
		assert 18, result6.length
	end

	# << From the page 433 >>
	# ---------------------------------------------------------------
	# arr.push(<obj>*) -> arr
	# ---------------------------------------------------------------
	# Appends the give arrgument(s) to arr.
	def test_Array_InstanceMethod_push
		assert ['a','b'], [].push(['a','b'])
	end

	# << From the page 433 >>
	# ---------------------------------------------------------------
	# arr.rassoc(key) -> an_array or nil
	# ---------------------------------------------------------------
	# Searches through the array whose elements are also arrays.
	# Compares key with the second element of each contained array
	# using ==. Returns the first contained array that matches. See
	# also Array#assoc.
	def test_Array_InstanceMethod_rassoc
		a = [[1,"One"],[2,"Two"],[3,"Three"]]
		assert [2,"Two"], a.rassoc("Two")
		assert a.rassoc("Four") == nil
	end

	# << From the page 433 >>
	# ---------------------------------------------------------------
	# arr.reject! { |item| ... } -> arr or nil
	# ---------------------------------------------------------------
	# Equivalent to Array#delete_if but 
	def test_Array_InstanceMethod_reject!
		a = [1,2,3,4,5,6]
		assert [1,2,3], a.reject! {|x| x<4}
		assert a.reject! {|x| x==10} == nil
	end

	# << From the page 433 >>
	# ---------------------------------------------------------------
	# arr.repeated_combination(length) {|comb| ...} -> arr
	#              arr.repeated_combination(length) -> enum
	# ---------------------------------------------------------------
	# Creates the set of combinations of length of the elements of arr.
	# If length is greater than arr.size, elements will be allowed to
	# repeat. Passes each combination to the block, or returns an
	# enumerator if no block is given.
	def test_Array_InstanceMethod_repeated_combination
		a = [1,2,3]
		result1 = [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
		result2 = [
			[1,1,1], [1,1,2], [1,1,3], [1,2,2], [1,2,3], [1,3,3],
			[2,2,2], [2,2,3], [2,3,3], [3,3,3]
		]
		# Mark: Need ruby 1_9_1_378
		# assert result1, a.repeated_combination(2).to_a
		# assert result2, a.repeated_combination(3).to_a
	end

	# << From the page 434 >>
	# ---------------------------------------------------------------
	# arr.repeated_permutation(length) {|comb| ...} -> arr
	#              arr.repeated_permutation(length) -> enum
	# ---------------------------------------------------------------
	# Creates the set of permutations of length of the elements of
	# arr. If length is greater than arr.size will be allowed to repeat.
	# Passes each permutation to the block, or returns an enumerator if
	# no block given.
	def test_Array_InstanceMethod_repeated_permutation
		a = [:a, :b]
		result1 = [[:a, :a], [:a, :b], [:b, :a], [:b, :b]]
		result2 = [
			[:a, :a, :a], [:a, :a, :b], [:a, :b, :a],
			[:a, :b, :b], [:b, :a, :a], [:b, :a, :b],
			[:b, :b, :a], [:b, :b, :b]
		]
		# # Mark: Need ruby 1_9_1_378
		# assert result1, a.repeated_permutation(2).to_a
		# assert result2, a.repeated_permutation(3).to_a
	end

	# << From the page 434 >>
	# ---------------------------------------------------------------
	# arr.replace(other_array) -> arr
	# ---------------------------------------------------------------
	# Replaces the contents of arr with the contents of other_array,
	# truncating or expanding arr if necessary.
	def test_Array_InstanceMethod_replace
		a = ['a','b','c','d','e']
		assert ['x','y','z'], a.replace(['x','y','z'])
		assert ['x','y','z'], a
	end

	# << From the page 434 >>
	# ---------------------------------------------------------------
	# arr.reverse -> an_array
	# ---------------------------------------------------------------
	# Returns a new array using arr's elements in reverse order.
	def test_Array_InstanceMethod_reverse
		assert ['c','b','a'], ['a','b','c'].reverse
		assert [1], [1].reverse
	end

	# << From the page 434 >>
	# ---------------------------------------------------------------
	# arr.reverse! -> arr
	# ---------------------------------------------------------------
	# Reverses arr in place.
	def test_Array_InstanceMethod_reverse!
		assert ['c','b','a'], ['a','b','c'].reverse!
		assert [1], [1].reverse!
	end

	# << From the page 434 >>
	# ---------------------------------------------------------------
	# arr.reverse_each {|item|...} -> arr
	# ---------------------------------------------------------------
	# Same as Array#each but traverses arr in reverse order.
	def test_Array_InstanceMethod_reverse_each
		a = ['a','b','c']; b = []
		a.reverse_each {|element| b.push(element)}
		assert ['c','b','a'], b
	end

	# << From the page 435 >>
	# ---------------------------------------------------------------
	#        arr.rindex(obj) -> int or nil
	# arr.rindex {|item|...} -> int or nil
	# ---------------------------------------------------------------
	# Returns the index of last object in arr that is == to obj or 
	# for which the block returns a true value. Returns nil if no
	# match is found. See also Enumerable#select and Array#index.
	def test_Array_InstanceMethod_rindex
		a = ['a','b','e','b','d']
		assert 3, a.rindex('b')
		assert a.rindex('z') == nil
		assert 2, a.rindex {|item| item =~ /[aeiou]/}
	end

	# << From the page 435 >>
	# ---------------------------------------------------------------
	# arr.rotate(places=1) -> new_array
	# ---------------------------------------------------------------
	# Returns a new array containing the elements of arr rotated places
	# positions (so that the element that originally was at arr[places]
	# is now at the front of the array.places may be negative.
	def test_Array_InstanceMethod_rotate
		a = [1,2,3,4,5]
		# assert [3,4,5,1,2], a.rotate(2)
		# assert [4,5,1,2,3], a.rotate(-2)
	end

	# << From the page 435 >>
	# ---------------------------------------------------------------
	# arr.rotate(places=1) -> arr
	# ---------------------------------------------------------------
	# Rotate arr in place.
	def test_Array_InstanceMethod_rotate!
		a = [1,2,3,4,5]
		# assert [3,4,5,1,2], a.rotate(2)
		# assert [4,5,1,2,3], a.rotate(-2)
	end

	# << From the page 435 >>
	# ---------------------------------------------------------------
	# arr.sample(n=1) -> an_array or nil
	# ---------------------------------------------------------------
	# Returns min(n, arr.size) random elements from arr or nil if
	# arr is empty and n is not given.
	def test_Array_InstanceMethod_sample
		a = ['a','b','c','d']
		assert 'c', a.sample
		assert ['b','a','c'], a.sample(3)
		assert ['b','d','a','c'], a.sample(6)
		assert [].sample == nil
	end

	# << From the page 435 >>
	# ---------------------------------------------------------------
	# arr.select! {|obj|...} -> array, nil, or enumerator
	# ---------------------------------------------------------------
	# Modifies arr by removing all elements for which block is false
	# (see also Enumerable#select and Array#keep_if). Returns nil if
	# no changes were made, returns an arr.
	def test_Array_InstanceMethod_select!
		a = [1,2,3,4,5,6,7,8,9]
		# TODO, need new ruby!
		# a.select {|element| element<6}
	end

	# << From the page 435-436 >>
	# ---------------------------------------------------------------
	# arr.shift(n=1) -> obj or nil
	# ---------------------------------------------------------------
	# Returns the first n elements (or the first element with no
	# argument) of arr and removes it (shifting all other elements
	# down by one). Returns nil if the array is empty.
	def test_Array_InstanceMethod_shift
		args = ["-m", "-q", "-v", "filename"]
		assert "-m", args.shift
		assert ["-q","-v"], args.shift(2)
		assert ["filename"], args
	end

	# << From the page 436 >>
	# ---------------------------------------------------------------
	#             arr.shuffle -> an_array
	# arr.shuffle(random:rng) -> an_array
	# ---------------------------------------------------------------
	# Returns an array containing the elements of arr in random order.
	# You can pass it a random number generator using the random:
	# keyword parameter. Passing rngs with the same seed makes the
	# shuffle deterministic.
	def test_Array_InstanceMethod_shuffle
		a = [1,2,3,4,5].shuffle
		b = [1,2,3,4,5].shuffle
		# c = [1,2,3,4,5].shuffle(random: Random.new(123))
		# d = [1,2,3,4,5].shuffle(random: Random.new(123))

		collect = [a,b]
		collect.each {|array| 
			array.each { |element| assert [1,2,3,4,5].include?(element) }
			assert_equal(5, array.length)
		}
	end

	# << From the page 436 >>
	# ---------------------------------------------------------------
	#             arr.shuffle -> an_array
	# arr.shuffle(random:rng) -> an_array
	# ---------------------------------------------------------------
	# Randomizes the order of the element of arr in place.
	def test_Array_InstanceMethod_shuffle!
		a = [1,2,3,4,5].shuffle!
		b = [1,2,3,4,5].shuffle!
		# c = [1,2,3,4,5].shuffle(random: Random.new(123))
		# d = [1,2,3,4,5].shuffle(random: Random.new(123))

		collect = [a,b]
		collect.each {|array| 
			array.each {|element| assert [1,2,3,4,5].include?(element)}
			assert 5, array.length
		}
	end

	# << From the page 436 >>
	# ---------------------------------------------------------------
	# arr.size -> int
	# ---------------------------------------------------------------
	# Synonym from Array#length.
	def test_Array_InstanceMethod_size
		assert 0, [].size
		assert 1, [1].size
		assert 2, [1,2].size
		assert 2, [1,2,].size
	end

	# << From the page 436 >>
	# ---------------------------------------------------------------
	#          arr.slice(int) -> obj
	# arr.slice(start,length) -> an_array
	#        arr.slice(range) -> an_array
	# ---------------------------------------------------------------
	# Synonym for Array#[]
	def test_Array_InstanceMethod_slice
		a=['a','b','c','d','e']
		assert_equal('cab', a.slice(2)+a.slice(0)+a.slice(1))
		assert_equal(nil, a.slice(6))
		assert_equal(['b','c'], a.slice(1,2))
		assert_equal(['b','c','d'], a.slice(1,3))
		assert_equal(['e'], a.slice(4,7))
		assert_equal(nil, a.slice(6..10))
		assert_equal(['c','d','e'], a.slice(-3,3))

		# special cases
		assert_equal(nil, a.slice(5))
		assert_equal([], a.slice(5, 1))
		assert_equal([], a.slice(5..10))
	end

	# << From the page 436-437 >>
	# ---------------------------------------------------------------
	#           arr.slice!(int) -> obj or nil
	# arr.slice!(start, length) -> an_array or nil
	#         arr.slice!(range) -> an_array or nil
	# ---------------------------------------------------------------
	# Deletes the elements(s) given by an index (optionally with a
	# length) or by a range. Returns the deleted object, subarray, or
	# nil if the index is out of range.
	def test_Array_InstanceMethod_slice!
		a = ['a','b','c']
		assert_equal('b', a.slice!(1))
		assert_equal(['a', 'c'], a)
		assert_equal('c', a.slice!(-1))
		assert_equal(['a'], a)
		assert_equal(nil, a.slice!(100))
		assert_equal(['a'], a)
	end

	# << From the page 437 >>
	# ---------------------------------------------------------------
	#            arr.sort! -> arr
	# arr.sort! {|a,b|...} -> arr
	# ---------------------------------------------------------------
	# Sorts arr in place (see Enumerable#sort).arr is effectively
	# frozen while a sort is in progress.
	def test_Array_InstanceMethod_sort!
		a = ['d','a','e','c','b']
		assert_equal(['a','b','c','d','e'], a.sort!)
		assert_equal(['a','b','c','d','e'], a)
	end

	# << From the page 437 >>
	# ---------------------------------------------------------------
	# arr.sort_by! {|a|...} -> arr
	#          arr.sort_by! -> enum
	# ---------------------------------------------------------------
	# Sorts arr in place (see Enumerable#sort_by).arr is effectively
	# frozen while a sort is in progress.
	def test_Array_InstanceMethod_sort_by!
		a = [5,2,7,4,8,9]
		# TODO, version can not supported.
		# assert_equal([2,4,8,5,7,9], a.sort_by! {|e| [e & 1, e]})
		# assert_equal([2,4,8,5,7,9], a)
	end

	# << From the page 437 >>
	# ---------------------------------------------------------------
	#            arr.to_a -> arr
	# array_subclass.to_a -> array
	# ---------------------------------------------------------------
	# If arr is an array, returns arr. If arr is a subclass of Array,
	# invokes to_ary and uses the result to create a new array object.
	def test_Array_InstanceMethod_toa
		assert_equal([1,2,3], [1,2,3].to_a)
		assert_equal([1.0,2.0,3.0], [1.0,2.0,3.0].to_a)
		assert_equal(['a','b'], ['a','b'].to_a)
	end

	# << From the page 437 >>
	# ---------------------------------------------------------------
	# arr.to_ary -> arr
	# ---------------------------------------------------------------
	# Returns arr.
	def test_Array_InstanceMethod_to_ary
		assert_equal([1,2,3], [1,2,3].to_ary)
		assert_equal([1.0,2.0,3.0], [1.0,2.0,3.0].to_ary)
		assert_equal(['a','b'], ['a','b'].to_ary)
	end	

	# << From the page 437 >>
	# ---------------------------------------------------------------
	# arr.to_s -> str
	# ---------------------------------------------------------------
	# Returns a string representation of arr. (In Ruby 1.9, the array
	# as a literal.)
	def test_Array_InstanceMethod_tos
		assert_equal("[1, 2]", [1,2].to_s)
		assert_equal("[1, 2, 3]", [1,2,3].to_s)
		assert_equal("[\"a\", \"b\"]", ['a','b'].to_s)
		assert_equal("[\"a\", \"b\", \"c\"]", ['a','b','c'].to_s)
	end

	# << From the page 437 >>
	# ---------------------------------------------------------------
	# arr.transpose -> an_array
	# ---------------------------------------------------------------
	# Assumes that arr is an array of arrays and transposes the rows
	# and columns.
	def test_Array_InstanceMethod_transpose
		a = [[1,2],[3,4],[5,6]]
		b = [['a','b'], ['c','d']]
		assert_equal([[1,3,5],[2,4,6]], a.transpose)
		assert_equal([['a','c'],['b','d']], b.transpose)
	end

	# << From the page 438 >>
	# ---------------------------------------------------------------
	# arr.uniq <{|element|...}> -> an_array
	# ---------------------------------------------------------------
	# Returns a new array by removing duplicate values in arr, where
	# duplicates are detected by comparing using eql? and hash. If the
	# block is present, the comparisons are made based on the values
	# returned by that block for each element in the array .
	def test_Array_InstanceMethod_uniq
		a = %w{ C a a b b A c a }
		assert_equal(["C","a","b","A","c"], a.uniq)
		# TODO, test failed
		# assert_equal(["C","a","b"], a.uniq {|char| char.downcase})
		# assert_equal(["C","a","b"], a.uniq(&:upcase))
	end

	# << From the page 438 >>
	# ---------------------------------------------------------------
	# arr.uniq! <{|element|...}> -> arr or nil
	# ---------------------------------------------------------------
	# Same as Array#uniq but modifies the receiver in place. Returns
	# nil if no changes are made (that is, no duplicates  are found).
	def test_Array_InstanceMethod_uniq!
		a = ['a','a','b','b','c']
		b = ['a','b','c']
		assert_equal(['a','b','c'], a.uniq!)
		assert_equal(nil, b.uniq!)
	end

	# << From the page 438 >>
	# ---------------------------------------------------------------
	# arr.unshift(<obj>+}) -> arr
	# ---------------------------------------------------------------
	# Prepends object(s) to arr
	def test_Array_InstanceMethod_unshift
		a = ['b','c','d']
		assert_equal(['a','b','c','d'], a.unshift('a'))
		assert_equal([1,2,'a','b','c','d'], a.unshift(1,2))
	end

	# << From the page 438 >>
	# ---------------------------------------------------------------
	# arr.values_at(<selector>*) -> an_array
	# ---------------------------------------------------------------
	# Returns an array containing the elements in arr corresponding
	# to the given selector(s). The selectors may be either indices
	# or ranges. Returns nil for selectors beyond the bounds of the
	# array.
	def test_Array_InstanceMethod_valuesat
		a = %w{ a b c d e f }
		assert_equal(['b','d','f'], a.values_at(1,3,5))
		assert_equal(['b','d','f',nil], a.values_at(1,3,5,7))
		assert_equal(['f','d','b',nil], a.values_at(-1,-3,-5,-7))
		assert_equal(['b','c','d','c','d','e','f'], a.values_at(1..3, 2..5))
		assert_equal(['f',nil,'b','c'], a.values_at(5..7, 1..2))
	end

end

# For test_UseTryConvert
class Stooges
	def to_ary
		["Larry", "Curly", "Moe"]
	end
end
